<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Murdered.</title>
<style>
    body {
        margin: 0;
        background: radial-gradient(circle at center, #111 0%, #050505 100%);
        color: #eaeaea;
        font-family: "Georgia", serif;
        overflow-x: hidden;
        perspective: 1000px;
    }

    section {
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 2rem;
    }

    h1 {
        font-size: 4.5rem;
        letter-spacing: 0.15em;
        opacity: 0;
        animation: fadeInTitle 4s ease forwards;
    }

    @keyframes fadeInTitle {
        to { opacity: 1; }
    }

    .fade-in {
        opacity: 0;
        transition: opacity 3s ease;
    }

    .visible {
        opacity: 1;
    }

    p {
        max-width: 750px;
        font-size: 1.25rem;
        line-height: 1.8;
    }

    .question {
        color: #aa0000;
        font-size: 2.1rem;
        margin-top: 2rem;
        font-weight: bold;
        opacity: 0;
    }

    .glitch {
        animation: flicker 0.15s infinite alternate,
                   glitchShift 0.2s infinite alternate;
    }

    @keyframes flicker {
        from { opacity: 0.5; }
        to { opacity: 1; }
    }

    @keyframes glitchShift {
        0% { text-shadow: 2px 0 red, -2px 0 black; transform: translateX(0); }
        50% { text-shadow: -2px 0 red, 2px 0 black; transform: translateX(2px); }
        100% { text-shadow: 2px 0 red, -2px 0 black; transform: translateX(-2px); }
    }

    /* Knife container */
    .knife-container {
        margin-top: 6rem;
        opacity: 0;
        transition: opacity 3s ease;
        transform-style: preserve-3d;
    }

    .knife-visible {
        opacity: 1;
        animation: rotateIn 8s ease forwards;
    }

    @keyframes rotateIn {
        from { transform: rotateY(75deg) scale(0.8); }
        to { transform: rotateY(0deg) scale(1); }
    }

    .knife {
        width: 90px;
        filter: drop-shadow(0 0 10px rgba(255,255,255,0.08));
        position: relative;
        overflow: visible;
    }

    /* Subtle shine sweep */
    .shine {
        position: absolute;
        top: 10%;
        left: -100%;
        width: 50%;
        height: 80%;
        background: linear-gradient(
            120deg,
            transparent,
            rgba(255,255,255,0.25),
            transparent
        );
        transform: skewX(-20deg);
        animation: shineMove 2s ease forwards;
    }

    @keyframes shineMove {
        to { left: 150%; }
    }

</style>
</head>
<body>

<section>
    <h1>Murdered.</h1>
</section>

<section>
    <div>
        <p class="fade-in" id="story">
            I was sitting alone, tiny lamp illuminating the desk in front of me.
            A text from my phone lights up my features,
            I read it and ponder upon the words written upon the screen.
        </p>

        <p class="question" id="question">
            If you were to be murdered, how would you like to go?
        </p>

        <div class="knife-container" id="knifeContainer">
            <div style="position:relative; display:inline-block;">
                <svg class="knife" viewBox="0 0 100 300">
                    <!-- Blade -->
                    <path d="M50 10 L65 200 L35 200 Z"
                          fill="silver" stroke="#ccc" stroke-width="2"/>
                    <!-- Handle -->
                    <rect x="40" y="200" width="20" height="80"
                          fill="#222"/>
                </svg>
                <div class="shine" id="shine"></div>
            </div>
        </div>

    </div>
</section>

<script>
    const story = document.getElementById("story");
    const question = document.getElementById("question");
    const knifeContainer = document.getElementById("knifeContainer");

    // Story reveal
    const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                story.classList.add("visible");

                setTimeout(() => {
                    question.style.opacity = "1";
                    question.classList.add("glitch");
                    startHeartbeat();
                }, 5000);

                observer.disconnect();
            }
        });
    }, { threshold: 0.6 });

    observer.observe(story);

    // Knife reveal after red text
    const knifeObserver = new IntersectionObserver(entries => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                knifeContainer.classList.add("knife-visible");
                playMetalScrape();
                knifeObserver.disconnect();
            }
        });
    }, { threshold: 0.6 });

    knifeObserver.observe(knifeContainer);

    // Heartbeat
    let heartbeatStarted = false;

    function startHeartbeat() {
        if (heartbeatStarted) return;
        heartbeatStarted = true;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function beat() {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = "sine";
            osc.frequency.setValueAtTime(80, audioCtx.currentTime);

            gain.gain.setValueAtTime(1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.15);
        }

        setInterval(() => {
            beat();
            setTimeout(beat, 250);
        }, 1200);
    }

    // Metallic scrape sound
    function playMetalScrape() {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.5, audioCtx.sampleRate);
        const data = noiseBuffer.getChannelData(0);

        for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * 0.3;
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = noiseBuffer;

        const filter = audioCtx.createBiquadFilter();
        filter.type = "bandpass";
        filter.frequency.value = 1000;
        filter.Q.value = 1;

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(audioCtx.destination);

        noise.start();
        noise.stop(audioCtx.currentTime + 1.2);
    }
</script>

</body>
</html>
